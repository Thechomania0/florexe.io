<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Florexe map editor</title>
  <script>
    (function() {
      var ADMIN_USERNAMES = ['thechomania'];
      var u = (localStorage.getItem('florexe_username') || '').trim().toLowerCase();
      if (!ADMIN_USERNAMES.includes(u)) {
        window.location.href = 'index.html' + (window.location.search || '');
        return;
      }
    })();
  </script>
  <style>
    * { box-sizing: border-box; }
    body { font-family: 'Segoe UI', sans-serif; margin: 12px; background: #1a1a1a; color: #e0e0e0; }
    h1 { font-size: 1.2rem; margin-bottom: 8px; }
    .toolbar { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
    button { padding: 8px 14px; cursor: pointer; background: #333; color: #eee; border: 1px solid #555; border-radius: 6px; }
    button:hover { background: #444; }
    button.primary { background: #1a5fb4; border-color: #2a7fd4; }
    button.primary:hover { background: #2a7fd4; }
    button.danger { background: #5a2a2a; border-color: #7a3a3a; }
    input[type="text"] { padding: 6px 10px; background: #252525; border: 1px solid #444; border-radius: 6px; color: #eee; font-size: 1rem; }
    .pen-palette { background: #fff; padding: 10px 12px; border-radius: 8px; display: inline-flex; align-items: center; flex-wrap: wrap; gap: 8px; margin-bottom: 10px; box-shadow: 0 1px 4px rgba(0,0,0,0.3); }
    .pen-palette label { color: #333; margin-right: 4px; }
    .pen-btn { width: 36px; height: 36px; padding: 0; border-radius: 8px; border: 3px solid transparent; cursor: pointer; }
    .pen-btn:hover { transform: scale(1.05); }
    .pen-btn.active { border-color: #333; box-shadow: 0 0 0 1px #333; }
    .brush-size-wrap { display: flex; align-items: center; gap: 8px; margin-left: 12px; padding-left: 12px; border-left: 1px solid #ddd; }
    .brush-size-wrap label { color: #333; font-size: 0.9rem; }
    .brush-size-wrap input[type="range"] { width: 100px; cursor: pointer; }
    #canvas { display: block; background: #2a2a2a; border: 1px solid #444; cursor: crosshair; image-rendering: pixelated; image-rendering: crisp-edges; }
    .info { margin-top: 10px; font-size: 0.9rem; color: #999; }
    .save-section { margin-top: 16px; padding: 12px; background: #252525; border-radius: 8px; border: 1px solid #444; }
    .save-section h3 { margin: 0 0 10px 0; font-size: 1rem; }
    .save-section button { margin-right: 8px; margin-top: 6px; }
    .msg { margin-top: 10px; padding: 8px 12px; border-radius: 6px; display: none; }
    .msg.success { background: #1a4d1a; color: #b8e6b8; display: block; }
    .maps-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
    .maps-row select { padding: 6px 10px; background: #252525; border: 1px solid #444; border-radius: 6px; color: #eee; min-width: 200px; }
    .maps-row label { color: #aaa; }
    .bucket-label { color: #333; display: flex; align-items: center; gap: 6px; cursor: pointer; }
    .bucket-label input { cursor: pointer; }
    .canvas-row { display: flex; gap: 16px; align-items: flex-start; flex-wrap: wrap; }
    .canvas-side { flex: 0 0 auto; padding: 12px; background: #252525; border-radius: 8px; border: 1px solid #444; min-width: 180px; }
    .canvas-side button { width: 100%; margin-top: 8px; }
    .default-map-row { display: flex; gap: 8px; align-items: center; margin: 12px 0 4px 0; }
    .default-map-row label { color: #aaa; font-size: 0.9rem; }
    .default-map-row select { padding: 6px 10px; background: #252525; border: 1px solid #444; border-radius: 6px; color: #eee; flex: 1; }
    .github-settings { margin: 10px 0; }
    .github-settings summary { cursor: pointer; color: #aaa; }
    .github-settings-row { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
    .github-settings-row label { min-width: 50px; color: #aaa; }
    .github-settings-row input { padding: 6px 10px; background: #252525; border: 1px solid #444; border-radius: 6px; color: #eee; flex: 1; max-width: 300px; }
  </style>
</head>
<body>
  <h1>Map editor — 400×400 grid (1:1 with game)</h1>
  <p class="info">1:1 scale: each square = one 40-unit square in the game. Black = wall. Rarity colors = spawn zones. Brown = player spawn.</p>

  <div class="toolbar">
    <label>Map name:</label>
    <input type="text" id="mapName" placeholder="My map" maxlength="60" />
    <button type="button" id="saveMap">Save</button>
    <button type="button" id="newMap">New map</button>
    <div class="maps-row">
      <label>Edit old map:</label>
      <select id="oldMaps"></select>
      <button type="button" id="loadMap">Load</button>
      <button type="button" id="deleteMap" class="danger">Delete map</button>
    </div>
    <button type="button" id="undo">Undo</button>
    <button type="button" id="clear" class="danger">Clear all</button>
    <button type="button" id="rotate90" title="Rotate entire map 90° clockwise">Rotate 90°</button>
    <button type="button" id="flipHorizontal" title="Mirror the entire map left-right">Flip horizontal</button>
    <span id="count">0 wall cells</span>
  </div>

  <div class="pen-palette">
    <label>Pen:</label>
    <button type="button" class="pen-btn active" id="penWall" title="Wall (black)"> </button>
    <button type="button" class="pen-btn" id="penCommon" title="Common–Uncommon zone"> </button>
    <button type="button" class="pen-btn" id="penRare" title="Rare–Epic zone"> </button>
    <button type="button" class="pen-btn" id="penLegendary" title="Legendary–Mythic zone"> </button>
    <button type="button" class="pen-btn" id="penUltra" title="Ultra–Super zone"> </button>
    <button type="button" class="pen-btn" id="penSpawn" title="Player spawn zone"> </button>
    <div class="brush-size-wrap">
      <label>Brush size:</label>
      <input type="range" id="brushSize" min="1" max="10" value="1" title="Brush stroke size (1–10 cells)" />
      <span id="brushSizeLabel">1</span>
    </div>
    <label class="bucket-label"><input type="checkbox" id="bucketMode" title="Bucket fill: click to fill connected area with current color" /> Bucket</label>
  </div>

  <div class="canvas-row">
    <canvas id="canvas"></canvas>
    <div class="canvas-side">
      <input type="file" id="importMapInput" accept=".json,application/json" style="display:none" />
      <button type="button" id="importMap" class="primary">Import map</button>
      <p class="info" style="margin-top:8px">Import a <code>custom-map.json</code> file to edit it on the canvas.</p>
      <div class="default-map-row">
        <label>Default for:</label>
        <select id="defaultGamemode">
          <option value="ffa">FFA</option>
          <option value="2tdm">2TDM</option>
          <option value="4tdm">4TDM</option>
          <option value="heaven">Heaven</option>
        </select>
      </div>
      <button type="button" id="saveAsDefault" class="primary" title="Replace data/custom-map.json in your repo. This becomes the map new users see.">Save as default</button>
      <p class="info" style="margin-top:8px;font-size:0.85rem">Default map = what new users see when cache is cleared. Requires GitHub token.</p>
    </div>
  </div>

  <div class="save-section">
    <h3>Use this map in the game</h3>
    <details class="github-settings">
      <summary>Store maps on GitHub</summary>
      <p class="info" style="margin:8px 0 4px 0">Maps can be stored in your GitHub repo so they sync across devices. Add a <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal Access Token</a> with <code>repo</code> scope to enable saving to GitHub.</p>
      <div class="github-settings-row">
        <label>Repo:</label>
        <input type="text" id="githubRepo" placeholder="Thechomania0/florexe.io" />
      </div>
      <div class="github-settings-row">
        <label>Token:</label>
        <input type="password" id="githubToken" placeholder="ghp_..." autocomplete="off" />
      </div>
    </details>
    <button type="button" id="saveConfirm" class="primary">Save and confirm implementation</button>
    <p class="info" style="margin-top:8px;margin-bottom:0">Reload the game after saving. Only black walls appear in-game; zones control spawn and rarity %.</p>
    <p class="info" style="margin-top:8px;margin-bottom:4px"><strong>Keep map across updates:</strong> Click &quot;Export for repo&quot; to download <code>custom-map.json</code>. Add it to your repo as <code>data/custom-map.json</code>, then push. The game will load this map whenever the browser has no saved map (e.g. new device or after clearing data).</p>
    <button type="button" id="exportForRepo" class="primary">Export for repo</button>
    <div id="saveMsg" class="msg"></div>
  </div>

  <script>
    const GRID_SIZE = 400;
    const SCALE = 40;
    const CELL_WORLD = SCALE;
    const GRID_WORLD_SPAN = GRID_SIZE * CELL_WORLD;
    const GRID_WORLD_MIN = -GRID_WORLD_SPAN / 2;
    const STORAGE_KEY = 'florexe_custom_walls';
    const ZONES_KEY = 'florexe_custom_zones';
    const API_BASE = window.FLOREXE_API_URL || '';
    const MAPS_KEY = 'florexe_map_editor_maps';
    const GITHUB_REPO_KEY = 'florexe_github_repo';
    const GITHUB_TOKEN_KEY = 'florexe_github_token';
    const GITHUB_MAPS_PATH = 'data/maps.json';
    const MAX_UNDO = 80;

    const CELL = { EMPTY: 0, WALL: 1, COMMON_UNCOMMON: 2, RARE_EPIC: 3, LEGENDARY_MYTHIC: 4, ULTRA_SUPER: 5, SPAWN: 6 };
    const PEN_COLORS = {
      [CELL.WALL]: '#1a1a1a',
      [CELL.COMMON_UNCOMMON]: '#bcec8b',
      [CELL.RARE_EPIC]: '#3c78d8',
      [CELL.LEGENDARY_MYTHIC]: '#ff0000',
      [CELL.ULTRA_SUPER]: '#c82dd1',
      [CELL.SPAWN]: '#8B4513'
    };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const countEl = document.getElementById('count');
    const mapNameEl = document.getElementById('mapName');
    const oldMapsEl = document.getElementById('oldMaps');
    const saveMsgEl = document.getElementById('saveMsg');

    const cellPx = 2;
    const size = GRID_SIZE * cellPx;
    canvas.width = size;
    canvas.height = size;

    let grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(CELL.EMPTY));
    let isDrawing = false;
    let drawValue = CELL.WALL;
    let history = [];
    let currentMapId = null;
    let currentPen = CELL.WALL;

    function deepCopyGrid(g) {
      return g.map(row => row.slice());
    }

    function pushHistory() {
      history.push(deepCopyGrid(grid));
      if (history.length > MAX_UNDO) history.shift();
    }

    function setPen(value) {
      currentPen = value;
      drawValue = value;
      document.querySelectorAll('.pen-btn').forEach((btn, idx) => {
        btn.classList.toggle('active', parseInt(btn.dataset.pen, 10) === value);
      });
    }

    function draw() {
      ctx.fillStyle = '#e8e8e8';
      ctx.fillRect(0, 0, size, size);

      for (let j = 0; j < GRID_SIZE; j++) {
        for (let i = 0; i < GRID_SIZE; i++) {
          const v = grid[i][j];
          if (v === CELL.EMPTY) continue;
          ctx.fillStyle = PEN_COLORS[v] || '#888';
          ctx.fillRect(i * cellPx, j * cellPx, cellPx, cellPx);
        }
      }

      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * cellPx, 0);
        ctx.lineTo(i * cellPx, size);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * cellPx);
        ctx.lineTo(size, i * cellPx);
        ctx.stroke();
      }

      const walls = grid.flat().filter(v => v === CELL.WALL).length;
      countEl.textContent = walls + ' wall cell(s)';
    }

    function gridToWorld(i, j) {
      return {
        x1: GRID_WORLD_MIN + i * CELL_WORLD,
        y1: GRID_WORLD_MIN + j * CELL_WORLD,
        x2: GRID_WORLD_MIN + (i + 1) * CELL_WORLD,
        y2: GRID_WORLD_MIN + (j + 1) * CELL_WORLD
      };
    }

    function buildSegmentsFromGrid() {
      const segments = [];
      const yAt = (j) => GRID_WORLD_MIN + j * CELL_WORLD;
      const x = (i) => GRID_WORLD_MIN + i * CELL_WORLD;
      for (let j = 0; j < GRID_SIZE; j++) {
        const y1 = yAt(j);
        const y2 = y1 + CELL_WORLD;
        for (let i = 0; i < GRID_SIZE; ) {
          if (grid[i][j] !== CELL.WALL) { i++; continue; }
          if (j > 0 && grid[i][j - 1] === CELL.WALL) { i++; continue; }
          let iEnd = i;
          while (iEnd + 1 < GRID_SIZE && grid[iEnd + 1][j] === CELL.WALL && (j === 0 || grid[iEnd + 1][j - 1] !== CELL.WALL)) iEnd++;
          segments.push({ x1: x(i), y1, x2: x(iEnd + 1), y2: y1 });
          i = iEnd + 1;
        }
        for (let i = 0; i < GRID_SIZE; ) {
          if (grid[i][j] !== CELL.WALL) { i++; continue; }
          if (j < GRID_SIZE - 1 && grid[i][j + 1] === CELL.WALL) { i++; continue; }
          let iEnd = i;
          while (iEnd + 1 < GRID_SIZE && grid[iEnd + 1][j] === CELL.WALL && (j === GRID_SIZE - 1 || grid[iEnd + 1][j + 1] !== CELL.WALL)) iEnd++;
          segments.push({ x1: x(iEnd + 1), y1: y2, x2: x(i), y2: y2 });
          i = iEnd + 1;
        }
      }
      for (let i = 0; i < GRID_SIZE; i++) {
        const x1 = x(i);
        const x2 = x(i + 1);
        for (let j = 0; j < GRID_SIZE; ) {
          if (grid[i][j] !== CELL.WALL) { j++; continue; }
          if (i > 0 && grid[i - 1][j] === CELL.WALL) { j++; continue; }
          let jEnd = j;
          while (jEnd + 1 < GRID_SIZE && grid[i][jEnd + 1] === CELL.WALL && (i === 0 || grid[i - 1][jEnd + 1] !== CELL.WALL)) jEnd++;
          const yTop = yAt(j);
          const yBot = yAt(jEnd) + CELL_WORLD;
          segments.push({ x1: x2, y1: yBot, x2: x2, y2: yTop });
          j = jEnd + 1;
        }
        for (let j = 0; j < GRID_SIZE; ) {
          if (grid[i][j] !== CELL.WALL) { j++; continue; }
          if (i < GRID_SIZE - 1 && grid[i + 1][j] === CELL.WALL) { j++; continue; }
          let jEnd = j;
          while (jEnd + 1 < GRID_SIZE && grid[i][jEnd + 1] === CELL.WALL && (i === GRID_SIZE - 1 || grid[i + 1][jEnd + 1] !== CELL.WALL)) jEnd++;
          const yTop = yAt(j);
          const yBot = yAt(jEnd) + CELL_WORLD;
          segments.push({ x1: x1, y1: yBot, x2: x1, y2: yTop });
          j = jEnd + 1;
        }
      }
      return segments;
    }

    function buildZoneGridForGame() {
      return grid.map(row => row.slice());
    }

    /** Rotate grid 90° clockwise: new[i][j] = old[j][GRID_SIZE-1-i] */
    function rotateGrid90() {
      const next = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(CELL.EMPTY));
      const n = GRID_SIZE - 1;
      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          next[i][j] = grid[j][n - i];
        }
      }
      return next;
    }

    /** Flip grid horizontally: new[i][j] = old[GRID_SIZE-1-i][j] */
    function flipGridHorizontal() {
      const next = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(CELL.EMPTY));
      const n = GRID_SIZE - 1;
      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          next[i][j] = grid[n - i][j];
        }
      }
      return next;
    }

    function getGitHubConfig() {
      const repoEl = document.getElementById('githubRepo');
      const tokenEl = document.getElementById('githubToken');
      const repo = (repoEl?.value || localStorage.getItem(GITHUB_REPO_KEY) || 'Thechomania0/florexe.io').trim();
      const token = (tokenEl?.value || localStorage.getItem(GITHUB_TOKEN_KEY) || '').trim();
      return { repo, token };
    }

    function getMapsListFromStorage() {
      try {
        const s = localStorage.getItem(MAPS_KEY);
        if (s) {
          const p = JSON.parse(s);
          if (Array.isArray(p)) return p;
        }
      } catch (e) {}
      return [];
    }

    function saveMapsListToStorage(list) {
      try {
        localStorage.setItem(MAPS_KEY, JSON.stringify(list));
      } catch (e) {}
    }

    async function getMapsListFromGitHub() {
      const { repo, token } = getGitHubConfig();
      if (!repo) return null;
      try {
        const branch = 'main';
        const url = 'https://raw.githubusercontent.com/' + repo + '/' + branch + '/' + GITHUB_MAPS_PATH;
        const r = await fetch(url + '?t=' + Date.now());
        if (r.ok) {
          const data = await r.json();
          return Array.isArray(data) ? data : null;
        }
      } catch (e) {}
      return null;
    }

    async function saveCustomMapAsDefaultToGitHub(gamemode) {
      const { repo, token } = getGitHubConfig();
      if (!repo || !token) return false;
      try {
        const segments = buildSegmentsFromGrid();
        const zoneGrid = buildZoneGridForGame();
        const data = { walls: segments, zones: { grid: zoneGrid } };
        const path = gamemode === 'ffa' ? 'data/custom-map.json' : ('data/custom-map-' + gamemode + '.json');
        const content = JSON.stringify(data, null, 2);
        const getRes = await fetch('https://api.github.com/repos/' + repo + '/contents/' + path, {
          headers: { Authorization: 'token ' + token }
        });
        let sha = null;
        if (getRes.ok) {
          const f = await getRes.json();
          sha = f.sha;
        }
        const putRes = await fetch('https://api.github.com/repos/' + repo + '/contents/' + path, {
          method: 'PUT',
          headers: {
            'Authorization': 'token ' + token,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: 'Set default map from map editor (' + gamemode + ')',
            content: btoa(unescape(encodeURIComponent(content))),
            ...(sha && { sha })
          })
        });
        return putRes.ok;
      } catch (e) {}
      return false;
    }

    async function saveMapsListToGitHub(list) {
      const { repo, token } = getGitHubConfig();
      if (!repo || !token) return false;
      try {
        const [owner, rep] = repo.split('/');
        if (!owner || !rep) return false;
        const getRes = await fetch('https://api.github.com/repos/' + repo + '/contents/' + GITHUB_MAPS_PATH, {
          headers: { Authorization: 'token ' + token }
        });
        let sha = null;
        if (getRes.ok) {
          const f = await getRes.json();
          sha = f.sha;
        }
        const content = JSON.stringify(list, null, 2);
        const putRes = await fetch('https://api.github.com/repos/' + repo + '/contents/' + GITHUB_MAPS_PATH, {
          method: 'PUT',
          headers: {
            'Authorization': 'token ' + token,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: 'Update maps from map editor',
            content: btoa(unescape(encodeURIComponent(content))),
            ...(sha && { sha })
          })
        });
        return putRes.ok;
      } catch (e) {}
      return false;
    }

    async function getMapsList() {
      try {
        const r = await fetch((API_BASE || '') + '/api/maps');
        if (r.ok) {
          const data = await r.json();
          if (Array.isArray(data)) return data;
        }
      } catch (e) {}
      const { token } = getGitHubConfig();
      if (token) {
        const gh = await getMapsListFromGitHub();
        if (gh && gh.length >= 0) return gh;
      }
      return getMapsListFromStorage();
    }

    async function saveMapToServer(id, name, gridCopy) {
      try {
        const r = await fetch((API_BASE || '') + '/api/maps', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: id || undefined, name, grid: gridCopy })
        });
        if (r.ok) {
          const d = await r.json();
          return d.id;
        }
      } catch (e) {}
      const list = await getMapsList();
      const newId = id || 'map_' + Date.now();
      const entry = { id: newId, name, grid: gridCopy, createdAt: Date.now() };
      const idx = list.findIndex(m => m.id === newId);
      if (idx >= 0) list[idx] = entry;
      else list.push(entry);
      if (await saveMapsListToGitHub(list)) return newId;
      saveMapsListToStorage(list);
      return newId;
    }

    async function deleteMapFromServer(id) {
      try {
        const r = await fetch((API_BASE || '') + '/api/maps/' + encodeURIComponent(id), { method: 'DELETE' });
        if (r.ok) return;
      } catch (e) {}
      const list = (await getMapsList()).filter(m => m.id !== id);
      if (await saveMapsListToGitHub(list)) return;
      saveMapsListToStorage(list);
    }

    async function refreshOldMapsSelect() {
      const list = await getMapsList();
      oldMapsEl.innerHTML = '<option value="">-- Choose a map --</option>';
      list.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m.id;
        opt.textContent = m.name || 'Unnamed';
        oldMapsEl.appendChild(opt);
      });
    }

    function getCell(ev) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const px = (ev.clientX - rect.left) * scaleX;
      const py = (ev.clientY - rect.top) * scaleY;
      const i = Math.floor(px / cellPx);
      const j = Math.floor(py / cellPx);
      if (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE) return [i, j];
      return null;
    }

    /** 4-connected flood fill: replace all cells with replaceValue connected to (i,j) with fillValue. */
    function floodFill(i, j, replaceValue, fillValue) {
      if (replaceValue === fillValue) return;
      const queue = [[i, j]];
      const visited = new Set();
      visited.add(i + ',' + j);
      let count = 0;
      const maxCells = GRID_SIZE * GRID_SIZE;
      while (queue.length > 0 && count < maxCells) {
        const [qi, qj] = queue.shift();
        if (grid[qi][qj] !== replaceValue) continue;
        grid[qi][qj] = fillValue;
        count++;
        for (const [di, dj] of [[-1,0],[1,0],[0,-1],[0,1]]) {
          const ni = qi + di, nj = qj + dj;
          if (ni < 0 || ni >= GRID_SIZE || nj < 0 || nj >= GRID_SIZE) continue;
          const key = ni + ',' + nj;
          if (visited.has(key)) continue;
          visited.add(key);
          if (grid[ni][nj] === replaceValue) queue.push([ni, nj]);
        }
      }
    }

    function getBrushSize() {
      const el = document.getElementById('brushSize');
      return el ? Math.max(1, Math.min(10, parseInt(el.value, 10) || 1)) : 1;
    }

    function paint(ev, value) {
      const cell = getCell(ev);
      if (!cell) return;
      const [ci, cj] = cell;
      const brush = getBrushSize();
      const half = Math.floor(brush / 2);
      let changed = false;
      for (let di = -half; di <= half; di++) {
        for (let dj = -half; dj <= half; dj++) {
          const i = ci + di, j = cj + dj;
          if (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE && grid[i][j] !== value) {
            grid[i][j] = value;
            changed = true;
          }
        }
      }
      if (changed) draw();
    }

    function showSaveMsg(text, isSuccess) {
      saveMsgEl.textContent = text;
      saveMsgEl.className = 'msg ' + (isSuccess ? 'success' : '');
      saveMsgEl.style.display = 'block';
      setTimeout(() => { saveMsgEl.style.display = 'none'; }, 4000);
    }

    canvas.addEventListener('mousedown', (ev) => {
      ev.preventDefault();
      const cell = getCell(ev);
      if (!cell) return;
      const [i, j] = cell;
      const bucketMode = document.getElementById('bucketMode').checked;
      if (bucketMode) {
        const fillValue = ev.button === 2 ? CELL.EMPTY : currentPen;
        const replaceValue = grid[i][j];
        if (replaceValue === fillValue) return;
        pushHistory();
        floodFill(i, j, replaceValue, fillValue);
        draw();
        return;
      }
      drawValue = ev.button === 2 ? CELL.EMPTY : currentPen;
      pushHistory();
      const brush = getBrushSize();
      const half = Math.floor(brush / 2);
      for (let di = -half; di <= half; di++) {
        for (let dj = -half; dj <= half; dj++) {
          const ni = i + di, nj = j + dj;
          if (ni >= 0 && ni < GRID_SIZE && nj >= 0 && nj < GRID_SIZE) {
            grid[ni][nj] = drawValue;
          }
        }
      }
      isDrawing = true;
      draw();
    });

    canvas.addEventListener('mousemove', (ev) => {
      if (!isDrawing) return;
      paint(ev, drawValue);
    });

    canvas.addEventListener('mouseup', () => { isDrawing = false; });
    canvas.addEventListener('mouseleave', () => { isDrawing = false; });
    canvas.addEventListener('contextmenu', (ev) => ev.preventDefault());

    document.getElementById('penWall').dataset.pen = CELL.WALL;
    document.getElementById('penWall').style.background = PEN_COLORS[CELL.WALL];
    document.getElementById('penCommon').dataset.pen = CELL.COMMON_UNCOMMON;
    document.getElementById('penCommon').style.background = PEN_COLORS[CELL.COMMON_UNCOMMON];
    document.getElementById('penRare').dataset.pen = CELL.RARE_EPIC;
    document.getElementById('penRare').style.background = PEN_COLORS[CELL.RARE_EPIC];
    document.getElementById('penLegendary').dataset.pen = CELL.LEGENDARY_MYTHIC;
    document.getElementById('penLegendary').style.background = PEN_COLORS[CELL.LEGENDARY_MYTHIC];
    document.getElementById('penUltra').dataset.pen = CELL.ULTRA_SUPER;
    document.getElementById('penUltra').style.background = PEN_COLORS[CELL.ULTRA_SUPER];
    document.getElementById('penSpawn').dataset.pen = CELL.SPAWN;
    document.getElementById('penSpawn').style.background = PEN_COLORS[CELL.SPAWN];

    document.querySelectorAll('.pen-btn').forEach(btn => {
      btn.onclick = () => setPen(parseInt(btn.dataset.pen, 10));
    });

    const brushSizeEl = document.getElementById('brushSize');
    const brushSizeLabel = document.getElementById('brushSizeLabel');
    if (brushSizeEl && brushSizeLabel) {
      brushSizeEl.addEventListener('input', () => { brushSizeLabel.textContent = brushSizeEl.value; });
    }

    document.getElementById('newMap').onclick = () => {
      pushHistory();
      grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(CELL.EMPTY));
      currentMapId = null;
      mapNameEl.value = '';
      history = [];
      draw();
      showSaveMsg('New map started.', true);
    };

    document.getElementById('loadMap').onclick = async () => {
      const id = oldMapsEl.value;
      if (!id) return;
      let m = null;
      try {
        const r = await fetch((API_BASE || '') + '/api/maps/' + encodeURIComponent(id));
        if (r.ok) m = await r.json();
      } catch (e) {}
      if (!m) m = (await getMapsList()).find(x => x.id === id);
      if (!m || !m.grid) { showSaveMsg('Map not found.', false); return; }
      try {
        let loaded = m.grid.map(row => row.slice());
        if (loaded[0] && typeof loaded[0][0] === 'boolean') {
          loaded = loaded.map(row => row.map(c => c ? CELL.WALL : CELL.EMPTY));
        }
        if (loaded.length === 80 && loaded[0] && loaded[0].length === 80) {
          const big = Array.from({ length: 400 }, () => Array(400).fill(CELL.EMPTY));
          for (let i = 0; i < 400; i++) {
            for (let j = 0; j < 400; j++) {
              big[i][j] = loaded[Math.floor(i / 5)][Math.floor(j / 5)];
            }
          }
          loaded = big;
        }
        grid = loaded;
        mapNameEl.value = m.name || '';
        currentMapId = m.id;
        history = [];
        draw();
        showSaveMsg('Map loaded.', true);
      } catch (e) {
        showSaveMsg('Could not load map.', false);
      }
    };

    document.getElementById('saveMap').onclick = async () => {
      const name = (mapNameEl.value || '').trim() || 'Unnamed';
      const gridCopy = deepCopyGrid(grid);
      try {
        const savedId = await saveMapToServer(currentMapId, name, gridCopy);
        currentMapId = savedId;
        await refreshOldMapsSelect();
        showSaveMsg('Saved. Load this map later from Edit old map.', true);
      } catch (e) {
        showSaveMsg('Could not save. Is the server running?', false);
      }
    };

    document.getElementById('deleteMap').onclick = async () => {
      const id = oldMapsEl.value;
      if (!id) {
        showSaveMsg('Choose a map from the dropdown to delete.', false);
        return;
      }
      try {
        await deleteMapFromServer(id);
        await refreshOldMapsSelect();
        if (currentMapId === id) {
          currentMapId = null;
          mapNameEl.value = '';
        }
        oldMapsEl.value = '';
        showSaveMsg('Map deleted.', true);
      } catch (e) {
        showSaveMsg('Could not delete. Is the server running?', false);
      }
    };

    document.getElementById('undo').onclick = () => {
      if (history.length === 0) return;
      grid = history.pop();
      draw();
    };

    document.getElementById('clear').onclick = () => {
      pushHistory();
      grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(CELL.EMPTY));
      draw();
    };

    function importCustomMapJson(data) {
      if (!data || !data.zones || !Array.isArray(data.zones.grid)) return false;
      const g = data.zones.grid;
      if (g.length !== 400) return false;
      const loaded = [];
      for (let i = 0; i < 400; i++) {
        const row = g[i];
        if (!Array.isArray(row) || row.length !== 400) return false;
        loaded.push(row.slice());
      }
      pushHistory();
      for (let i = 0; i < 400; i++) {
        for (let j = 0; j < 400; j++) {
          const v = loaded[i][j];
          grid[i][j] = (typeof v === 'number' && v >= 0 && v <= 6) ? v : CELL.EMPTY;
        }
      }
      return true;
    }

    document.getElementById('importMap').onclick = () => {
      document.getElementById('importMapInput').click();
    };
    document.getElementById('saveAsDefault').onclick = async () => {
      const gamemode = (document.getElementById('defaultGamemode')?.value || 'ffa').trim();
      if (!getGitHubConfig().token) {
        showSaveMsg('Add a GitHub token in "Store maps on GitHub" to save as default.', false);
        return;
      }
      const ok = await saveCustomMapAsDefaultToGitHub(gamemode);
      if (ok) {
        showSaveMsg('Saved as default map. New users will see this map when cache is cleared.', true);
      } else {
        showSaveMsg('Could not save as default. Check token and repo.', false);
      }
    };

    document.getElementById('importMapInput').addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      e.target.value = '';
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          if (importCustomMapJson(data)) {
            draw();
            showSaveMsg('Map imported. You can now edit it.', true);
          } else {
            showSaveMsg('Invalid custom-map.json. Need zones.grid (400×400).', false);
          }
        } catch (err) {
          showSaveMsg('Could not parse JSON: ' + (err.message || 'Invalid file'), false);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById('rotate90').onclick = () => {
      pushHistory();
      grid = rotateGrid90();
      draw();
      showSaveMsg('Map rotated 90° clockwise.', true);
    };

    document.getElementById('flipHorizontal').onclick = () => {
      pushHistory();
      grid = flipGridHorizontal();
      draw();
      showSaveMsg('Map flipped horizontally.', true);
    };

    document.getElementById('saveConfirm').onclick = async () => {
      const segments = buildSegmentsFromGrid();
      const zoneGrid = buildZoneGridForGame();
      const name = (mapNameEl.value || '').trim() || 'Unnamed';

      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(segments));
        localStorage.setItem(ZONES_KEY, JSON.stringify({ grid: zoneGrid }));
      } catch (e) {
        showSaveMsg('Failed to save: ' + e.message, false);
        return;
      }

      try {
        const savedId = await saveMapToServer(currentMapId, name, deepCopyGrid(grid));
        currentMapId = savedId;
        await refreshOldMapsSelect();
      } catch (e) {
        showSaveMsg('Saved to browser, but could not save to server. Is the server running?', false);
      }

      showSaveMsg('Map saved. Reload the game to use it.', true);
    };

    document.getElementById('exportForRepo').onclick = () => {
      const segments = buildSegmentsFromGrid();
      const zoneGrid = buildZoneGridForGame();
      const data = { walls: segments, zones: { grid: zoneGrid } };
      const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'custom-map.json';
      a.click();
      URL.revokeObjectURL(a.href);
      showSaveMsg('Downloaded custom-map.json. Add it to your repo as data/custom-map.json and push.', true);
    };

    const githubRepoEl = document.getElementById('githubRepo');
    const githubTokenEl = document.getElementById('githubToken');
    if (githubRepoEl) {
      githubRepoEl.value = localStorage.getItem(GITHUB_REPO_KEY) || 'Thechomania0/florexe.io';
      githubRepoEl.addEventListener('change', () => { localStorage.setItem(GITHUB_REPO_KEY, githubRepoEl.value.trim()); });
    }
    if (githubTokenEl) {
      githubTokenEl.value = localStorage.getItem(GITHUB_TOKEN_KEY) || '';
      githubTokenEl.addEventListener('change', () => { localStorage.setItem(GITHUB_TOKEN_KEY, githubTokenEl.value.trim()); });
    }

    refreshOldMapsSelect().then(() => {}).catch(() => {});
    draw();
  </script>
</body>
</html>
